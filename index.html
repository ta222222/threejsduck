<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>glTF Model Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #222;
      }
      #container {
        width: 100vw;
        height: 100vh;
      }
      #controls-info {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.5); /* Transparent background */
        color: #ddd; /* Grey text */
        padding: 10px;
        border-radius: 5px;
        z-index: 10; /* Ensure it's above the canvas */
        font-size: 0.8em;
        font-family: sans-serif;
        width: 200px;
      }
      #controls-info p {
        margin: 5px 0;
        line-height: 1.2;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <div id="controls-info">
      <p><strong>Mouse Controls:</strong></p>
      <p>Left Mouse: Rotate</p>
      <p>Right Mouse: Pan</p>
      <p>Mouse Wheel: Zoom</p>
      <p>Double Click: Zoom To</p>
      <p><strong>Keyboard Controls:</strong></p>
      <p>W/A/S/D: Move</p>
      <p>▲/▼/◀/▶: Rotate</p>
    </div>
    <script>
      let scene, camera, renderer, controls;
      let model; // Will hold the loaded model

      // Movement and Rotation Speed
      let moveSpeed = 0.1;
      let rotationSpeed = 0.01;
      let zoomSpeed = 0.05;
      let isPanning = false;

      let keys = {}; // To store pressed keys

      function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222); // Dark grey background

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 5, 15); // Adjusted initial camera position

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows for realism
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows
        document.getElementById("container").appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Add damping for smoother interaction
        controls.dampingFactor = 0.1;
        controls.screenSpacePanning = true; // Enable panning with mouse buttons
        controls.minDistance = 5; // Min distance to the target
        controls.maxDistance = 50; // Max distance to the target
        controls.target.set(0, 0, 0); // Set the target point
        controls.update(); // Update controls to reflect initial camera position
        controls.enabled = false; // Disable the default controls.  We'll manage them.

        // Lighting
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x404040, 0.7); // Sky color, ground color, intensity
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 20;
        scene.add(directionalLight);

        // Load the model
        loadModel();

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);
        // Mouse events
        renderer.domElement.addEventListener("mousedown", onMouseDown, false);
        renderer.domElement.addEventListener("mouseup", onMouseUp, false);
        renderer.domElement.addEventListener("mousemove", onMouseMove, false);
        renderer.domElement.addEventListener("wheel", onMouseWheel, false);
        renderer.domElement.addEventListener("dblclick", onDoubleClick, false);


        // Keyboard events
        window.addEventListener("keydown", onKeyDown, false);
        window.addEventListener("keyup", onKeyUp, false);

        // Start the animation loop
        animate();
      }

      function loadModel() {
        const loader = new THREE.GLTFLoader();
        const gltfUrl = "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/Duck/glTF-Binary/Duck.glb";
        loader.load(
          gltfUrl, // Public URL to the model
          function (gltf) {
            model = gltf.scene;
            // Scale the model if necessary
            model.scale.set(3, 3, 3);
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            scene.add(model);

            // Center the model and adjust camera
            centerModel(model);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          function (error) {
            console.error("Error loading glTF model:", error);
          }
        );
      }
      function centerModel(model) {
        const boundingBox = new THREE.Box3();
        boundingBox.setFromObject(model);
        const center = new THREE.Vector3();
        boundingBox.getCenter(center);

        // Reposition the model to the origin
        model.position.set(-center.x, -center.y, -center.z);

        // Get the size of the bounding box
        const size = new THREE.Vector3();
        boundingBox.getSize(size);

        // Calculate the maximum dimension of the model
        const maxDimension = Math.max(size.x, size.y, size.z);
        const fitHeightDistance = maxDimension / (2 * Math.atan(Math.PI * camera.fov / 360));
        const fitWidthDistance = fitHeightDistance / camera.aspect;
        const distance = Math.max(fitHeightDistance, fitWidthDistance) * 1.2;

        const centerWorld = new THREE.Vector3();
        model.getWorldPosition(centerWorld);
        camera.position.set(centerWorld.x, centerWorld.y, centerWorld.z + distance); // Adjust camera position
        controls.target.set(centerWorld.x, centerWorld.y, centerWorld.z); // Point controls to model center
        controls.update();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };
      function onMouseDown(event) {
        if (event.button === 0) {
          isDragging = true;
          previousMousePosition = { x: event.clientX, y: event.clientY };
        } else if (event.button === 2) {
          isPanning = true;
          controls.enabled = true;
          previousMousePosition = { x: event.clientX, y: event.clientY };
        }
      }

      function onMouseUp(event) {
        if (event.button === 0) {
          isDragging = false;
        } else if (event.button === 2) {
          isPanning = false;
          controls.enabled = false;
        }
      }

      function onMouseMove(event) {
        if (isDragging) {
          const deltaX = event.clientX - previousMousePosition.x;
          const deltaY = event.clientY - previousMousePosition.y;

          // Rotate the scene based on mouse movement
          scene.rotation.y += deltaX * rotationSpeed;
          scene.rotation.x += deltaY * rotationSpeed;

          previousMousePosition = { x: event.clientX, y: event.clientY };
        } else if (isPanning) {
          const deltaX = event.clientX - previousMousePosition.x;
          const deltaY = event.clientY - previousMousePosition.y;

          controls.pan(new THREE.Vector3(-deltaX * 0.01, deltaY * 0.01, 0));
          previousMousePosition = { x: event.clientX, y: event.clientY };
        }
      }

      function onMouseWheel(event) {
        event.preventDefault(); // Prevent page scroll

        if (event.deltaY < 0) {
          // Zoom in
          camera.position.z -= zoomSpeed;
        } else if (event.deltaY > 0) {
          // Zoom out
          camera.position.z += zoomSpeed;
        }
        controls.update();
      }

      function onDoubleClick(event) {
        // Zoom to the origin (0,0,0)
        camera.position.set(0, 5, 15); // Or any other suitable position
        controls.target.set(0, 0, 0);
        controls.update();
      }

      function onKeyDown(event) {
        keys[event.key] = true;
      }

      function onKeyUp(event) {
        keys[event.key] = false;
      }

      function handleKeyboardMovement() {
        if (keys["w"] || keys["W"]) camera.position.z -= moveSpeed;
        if (keys["s"] || keys["S"]) camera.position.z += moveSpeed;
        if (keys["a"] || keys["A"]) camera.position.x -= moveSpeed;
        if (keys["d"] || keys["D"]) camera.position.x += moveSpeed;

        if (keys["ArrowUp"]) scene.rotation.x -= rotationSpeed;
        if (keys["ArrowDown"]) scene.rotation.x += rotationSpeed;
        if (keys["ArrowLeft"]) scene.rotation.y -= rotationSpeed;
        if (keys["ArrowRight"]) scene.rotation.y += rotationSpeed;
      }

      function animate() {
        requestAnimationFrame(animate);
        handleKeyboardMovement(); // Handle keyboard input
        controls.update(); // Don't forget to update controls in the animation loop!
        renderer.render(scene, camera);
      }

      // Initialize everything
      init();
    </script>
  </body>
</html>
